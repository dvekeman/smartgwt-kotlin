@file:JsQualifier("isc")
package isc

/**
 *  Standalone class providing a general interface for integration with Automated Testing Tools
 * 
 * 
 *   For automated testing tools we need a way to create string identifiers for DOM elements such that
 *   when a page is reloaded, we can retrieve a functionally equivalent DOM element. We call these
 *   AutoTestLocator.
 * 
 *   This allows automated testing tools to set up or record user generated events on DOM elements
 *   then play them back on page reload and have our components react correctly.
 * 
 *   The primary APIs for the AutoTest subsystem are AutoTest.getLocator and
 *   AutoTest.getElement.
 * 
 *   Implementation considerations:
 * 
 * 
 *  - Some components react to the structure of DOM elements embedded within them - for example
 *    GridRenderer cells have meaning to the grid. So in some cases we need to identify elements
 *    within a component, while in others we can just return a pointer to a handle (A simple
 *    canvas click handler doesn't care about what native DOM element within the handle received
 *    the click).
 * 
 * 
 *  - When a DOM element is contained by a component, it is not sufficient to store the component
 *    ID. Most SmartClient components are auto-generated by their parents, and rather than
 *    attempting to store a specific component identifier we should instead store the
 *    "logical function" of the component.
 *    For example a listGrid header button may have a different auto-generated ID across page
 *    reloads due to various timing-related issues (which can change the order of of widget
 *    creation), loading a new skin, or otherwise trivial changes to an application.
 *    Rather than storing the header button ID therefore, we want to store this as
 *    a string meaning "The header button representing field X within this list grid".
 * 
 * 
 *  - fallback strategies: In some cases a component or DOM element can be identified in
 *    several ways. For example a cell in a ListGrid can be identified by simple row and
 *    column index, but also by fieldName and record primary key value. In these cases we
 *    attempt to record information for multiple locator strategies and then when parsing
 *    stored values we can provide APIs to govern which strategy is preferred. See the
 *    LocatorStrategy documentation for more on this.
 * 
 * 
 *   In order to address these concerns the AutoTest locator pattern is similar to an
 *   XPath type structure, containing a root component identifier, followed by
 *   details of sub-components and then potentially details used to identify an element within
 *   the components handle in the DOM.
 * 
 *   The actual implementation covers a large number of common cases, including (but not limited to)
 *   the following. Note that for cases where an element is being identified from a pool of
 *   possible candidates, such as the Canvas.children array, we usually will use
 *   LocatorStrategy rather than simply relying on index:
 * 
 *  - Root level components identified by explicit ID
 * 
 *  - Any AutoChild
 * 
 *  - Standard component parts such as scrollbars, edges, shadows, etc
 * 
 *  - Section stack items and headers
 * 
 *  - Window items
 * 
 *  - ListGrid headers and cells
 * 
 *  - TreeGrid headers and cells, including interactive open icon, checkbox icons
 * 
 *  - DynamicForm form items, including details of elements within those items
 * 
 * 
 */
open external class AutoTest : Class {
    companion object {
        /**
         *  Controls whether certain AutoTest APIs wait for network operations to complete
         *   before returning true. When value is true, AutoTest.isElementClickable
         *   will return false until all network operations have completed.
         *  @type {boolean}
         *  @default false
         */
        var implicitNetworkWait: Boolean = definedExternally
        /**
         *  Sets the implicit root canvas available in scLocators starting "//testRoot[]".
         *   Setting this property may enable one to use the same script to test identical
         *   widget hierarchies that are rooted under different base widgets.
         *  @type {Canvas}
         *  @default null
         */
        var testRoot: Canvas = definedExternally
        /**
         *  Creates a new AutoTest
         * 
         *  @param typeCheckedProperties {Partial<AutoTest>=} Object literal containing init properties that will be checked against the class field types.
         *  @param uncheckedProperties {Object} Object literal containing init properties that will not be checked against the class field types.
         *  @return {AutoTest} The new instance
         */
        fun create(typeCheckedProperties: dynamic?, uncheckedProperties: Object?): AutoTest = definedExternally
        /**
         *   Returns the AutoTestLocator associated with some DOM element in a SmartClient
         *   application page. If coords, representing the page position, is passed in, the locator
         *   may be generated with a specific trailing "target area" identifer that will map back to
         *   the appropriate, potentially different, physical coordinates, even if the widget is
         *   moved. The coords argument will only have an effect in cases where the mouse position
         *   over the target could potentially change behavior.
         * 
         *  @param {DOMElement} DOM element within in the page. If null the locator for the last mouse event target will be generated
         *  @param {boolean=} If this parameter is passed in, check whether the target element responds to native browser events directly rather than going through  the SmartClient widget/event handling model. If we detect this case, return null rather  than a live locator. This allows us to differentiate between (for example) an event on  a Canvas handle, and an event occurring directly on a simple  &lt;a href=...&gt; tag written inside a Canvas handle.
         *  @param {Array<any>=} X, Y page position
         */
        fun getLocator(DOMElement: DOMElement, checkForNativeHandling: Boolean?, coords: Array<dynamic>?): String = definedExternally
        /**
         *   Given an element in the DOM, returns the canvas containing this element, or null if
         *   the element is not contained in any canvas handle.
         * 
         *  @param {DOMElement} DOM element within in the page
         */
        fun locateCanvasFromDOMElement(element: DOMElement): Unit = definedExternally
        /**
         *  @param {AutoTestLocator} Locator String previously returned by    AutoTest.getLocator
         */
        fun getElement(locator: String): DOMElement = definedExternally
        /**
         *   Given an AutoTestLocator, return the live SmartClient object it refers to, if any.
         * 
         *  @param {AutoTestLocator} Locator String previously returned by    AutoTest.getLocator
         */
        fun getObject(locator: String): dynamic = definedExternally
        /**
         *   Given an AutoTestLocator that refers to a live SmartClient object or a logical
         *   subcomponent of that object, return the associated meaningful JS value, if any.
         * 
         *   For example:
         * 
         * 
         *  - For a locator to a ListGrid/CubeGrid cell, return the cell's value
         * 
         *  - For a locator to a FormItem, return the FormItem's value
         * 
         *  - For a locator to a ListGrid field header, return the checkbox/sorting state
         * 
         *  - For a locator to a Calendar EventCanvas header or body, return the text
         * 
         * 
         *  @param {AutoTestLocator} Locator String previously returned by    AutoTest.getLocator
         */
        fun getValue(locator: String): dynamic = definedExternally
        /**
         *   Returns the page-level coordinates corresponding to the supplied locator. Note: The
         *   physical position might change due to app redesign, but these coordinates would still
         *   reflect the same logical part of the DOM element for components where event position
         *   matters.
         * 
         *  @param {AutoTestLocator} Locator String previously returned by    AutoTest.getLocator
         */
        fun getPageCoords(locator: String): Array<dynamic> = definedExternally
        /**
         *   Sets the implicit root canvas available in scLocators starting "//testRoot[]".
         *   Setting this property may enable one to use the same script to test identical
         *   widget hierarchies that are rooted under different base widgets.
         * 
         *  @param {Canvas} the implicit root
         */
        fun setTestRoot(canvas: Canvas): Unit = definedExternally
        /**
         *   Returns whether the canvas associated with the given DOM element
         *   is in a consistent state with no pending operations. Returns null
         *   if the argument is not valid or isn't associated with an element
         *   representing a valid canvas.
         *   Otherwise, returns true or false according as the conditions below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - canvas is drawn
         * 
         *  - canvas isn't dirty
         * 
         *  - canvas has no queued overflow operations
         * 
         *  - canvas is not animating
         * 
         * 
         *  @param {Canvas | DOMElement | AutoTestLocator}  DOM element to test (element obtained from canvas or SmartClient locator if provided)
         */
        fun isCanvasDone(element: dynamic): Boolean = definedExternally
        /**
         *   Returns whether the TileLayout associated with the given DOM element
         *   is in a consistent state with no pending operations. Returns null if the
         *   argument is not valid or isn't associated with an element representing
         *   a valid TileLayout.
         *   Otherwise, returns true or false according as the conditions below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - the TileLayout (as a canvas) satisfies AutoTest.isCanvasDone
         * 
         *  - the TileLayout is not currently animating any layout operations
         * 
         * 
         *  @param {Canvas | DOMElement | AutoTestLocator}  DOM element to test (element obtained from canvas or SmartClient locator if provided)
         */
        fun isTileLayoutDone(element: dynamic): Boolean = definedExternally
        /**
         *   Returns whether the TileGrid associated with the given DOM element
         *   is in a consistent state with no pending operations. Returns null if the
         *   argument is not valid or isn't associated with an element representing
         *   a valid TileGrid.
         *   Otherwise, returns true or false according as the conditions below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - the TileGrid (as a tileLayout) satisfies AutoTest.isTileLayoutDone
         * 
         *  - the TileGrid has no pending layout animation operations queued
         * 
         * 
         *  @param {Canvas | DOMElement | AutoTestLocator}  DOM element to test (element obtained from canvas or SmartClient locator if provided)
         */
        fun isTileGridDone(element: dynamic): Boolean = definedExternally
        /**
         *   Returns whether the DynamicForm associated with the given DOM element
         *   is in a consistent state with no pending operations. Returns null
         *   if the argument is not valid or isn't associated with an element
         *   representing a valid
         *   DynamicForm. Otherwise, returns true or false according as the conditions
         *   below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - form has no pending delayed "set values" or "set values focus" operations
         * 
         *  - all contained items satisfy AutoTest.isItemDone
         * 
         * 
         *  @param {Canvas | DOMElement | AutoTestLocator}  DOM element to test (element obtained from canvas or SmartClient locator if provided)
         */
        fun isFormDone(element: dynamic): Boolean = definedExternally
        /**
         *   Returns whether the FormItem associated with the given DOM element
         *   is in a consistent state with no pending operations. Returns null
         *   if the argument is not valid or isn't associated with an element
         *   representing a valid
         *   FormItem. Otherwise, returns true or false according as the conditions
         *   below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - if the container widget of the item isn't the parent DynamicForm, then the
         *       container widget must satisfy AutoTest.isCanvasDone (or AutoTest.isGridDone,
         *       etc., as appropriate)
         * 
         *  - the item cannot have any fetches in progress for missing display/value field
         *       values
         * 
         *  - picklists (SelectItem or ComboBoxItem) cannot have any pending row
         *       fetches
         * 
         *  - any contained FormItems must satisfy isItemDone() themselves
         * 
         *  - any contained Canvas must satisfy AutoTest.isCanvasDone (or
         *       AutoTest.isGridDone, etc., as appropriate)
         * 
         * 
         *  @param {FormItem | DOMElement | AutoTestLocator}  DOM element to test (element obtained from canvas or SmartClient locator if provided)
         */
        fun isItemDone(element: dynamic): Boolean = definedExternally
        /**
         *   Returns whether the ListGrid associated with or contained by the given
         *   DOM element
         *   is in a consistent state with no pending operations. Returns null if the
         *   argument is not valid or isn't associated with an element inside a valid ListGrid.
         * 
         *   Otherwise, returns true or false according as the conditions below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - no pending scroll operations
         * 
         *  - no pending filter editor operations
         * 
         *  - no unsaved edits to the grid records
         * 
         *  - no asynchronous regrouping operations are in progress
         * 
         *  - no outstanding fetch/filter operations are present for the ResultSet
         * 
         *  - no outstanding sort operations are present that will update the ListGrid
         * 
         * 
         *  @param {Canvas | DOMElement | AutoTestLocator}  DOM element to test (element obtained from canvas or SmartClient locator if provided)
         */
        fun isGridDone(element: dynamic): Boolean = definedExternally
        /**
         *   Returns whether the DOM element
         *   is ready to be clicked on by a Selenium test. Returns null if the
         *   argument is not valid or isn't associated with an element representing
         *   a valid canvas or form item.
         *   Otherwise, returns true or false according as the conditions below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - no network operations are outstanding (configurable,
         *       see AutoTest.implicitNetworkWait)
         * 
         *  - canvas is visible, enabled, and not masked,
         * 
         *  - canvas satisfies AutoTest.isCanvasDone
         * 
         *  - if canvas is a TileGrid, it satisfies AutoTest.isTileGridDone
         * 
         *  - if canvas is a TileLayout, it satisfies AutoTest.isTileLayoutDone
         * 
         *  - if canvas is a ListGrid or body of a ListGrid, it satisfies AutoTest.isGridDone
         * 
         *  - if canvas is a DynamicForm, it satisfies AutoTest.isFormDone
         * 
         *   Note that for a form item in a DynamicForm, the DynamicForm must satisfy the third
         *   condition above, while the container widget of the element must satisfy the remaining
         *   conditions.
         * 
         * 
         *  @param {Canvas | FormItem | DOMElement | AutoTestLocator}  DOM element to test (element obtained from canvas, form item, or SmartClient locator if provided)
         */
        fun isElementClickable(element: dynamic): Boolean = definedExternally
        /**
         *   Given a DOM element, returns whether the associated SmartClient Canvas or FormItem is
         *   ready to receive keyPress events from a Selenium test. Returns null if the locator is
         *   not valid or doesn't represent a valid Canvas or FormItem. Otherwise, returns true or
         *   false according as the conditions below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - if a TextItem, FileItem, or TextAreaItem,
         *       it has native focus,
         * 
         *  - the element satisfies AutoTest.isElementClickable
         * 
         * 
         *  @param {Canvas | FormItem | DOMElement | AutoTestLocator} DOM element to test   (element obtained from canvas, form item, or SmartClient locator if provided)
         */
        fun isElementReadyForKeyPresses(element: dynamic): Boolean = definedExternally
        /**
         *   Returns whether the loaded page is in a consistent state with no pending operations.
         *   Specifically, returns true of false according as the conditions below are all satisfied:
         * 
         * 
         *  - page has finished loading
         * 
         *  - all ListGrids (as defined by isc.isA.ListGrid) satisfy AutoTest.isGridDone
         * 
         *  - all TileGrids that are drawn satisfy AutoTest.isTileGridDone
         * 
         *  - all TileLayouts that are drawn satisfy AutoTest.isTileLayoutDone
         * 
         *  - all DynamicForms that are drawn satisfy AutoTest.isFormDone
         * 
         *  - all Canvii that are drawn satisfy AutoTest.isCanvasDone
         * 
         *  - no network operations are outstanding (configurable,
         *       see AutoTest.implicitNetworkWait)
         * 
         *  - there are no pending Canvas redraws (if includeRedraws parameter is true)
         * 
         *   Note: In a situation where messaging is being used to periodically refresh components,
         *   or if the application contains a label updated every second to show the current time,
         *   it's possible that this call might always return false if includeRedraws is true.
         * 
         *  @param {boolean=} whether to check for pending Canvas redraws
         *  @param {boolean=} whether to allow unsaved edits for ListGrids
         */
        fun isSystemDone(includeRedraws: Boolean?, allowEdits: Boolean?): Boolean = definedExternally
    }
}